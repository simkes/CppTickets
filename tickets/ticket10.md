## Билет 10 Базовый синтаксис

### Встроенные типы
[типы](https://en.cppreference.com/w/cpp/language/types)
int - целые числа, в стандарте - минимум 2 байта, обычно 4. Диапазон значений от -2^31 до 2^31 (от −2 · 10^9 до 2 · 10^9).
double - вещественные, обычно 8 байт, диапазон приблизительно 18 единиц. 
0.1 + 0.2 != 0.3, тк компьютер хранит числа в 2СС, поэтому все приблизительно 
(long long - обычно 8 байт, от -2^63 до 2^63  (−9 · 10^18 до 9 · 10^18))
bool - обычно 1 байт, true(1) / false(0), по историческим причинам причисляется к целочисленным   [примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/01-bool.cpp)
char - обычно 1 байт и знаковый, диапазон от -128 до 127, в арифметике ведет себя как целочисленный: [примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/03-char.cpp)
signed - знаковый
unsigned - беззнаковый, значения из отрицательного диапазона перекидываются в положительный (unsigned int от 0 до 2^32), переполнение - берется по модулю (переполнение знакового - UB!).
### Литералы
Литералы - это значения, которые вставляются непосредственно в код. 
[примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/02-210909/01-trivial-types/04-literals.cpp)
целочисленный - префикс - основание (СС), суффикс U -unsigned, L - long
вещественный - по умолчанию double, если дописать f ==> float, L ==> long double 
символьный - символьная константа в ' ' или обратный слеш + символ (например [escape-последовательности](https://en.cppreference.com/w/cpp/language/escape)) ,  применяются коды из ASCII или Unicode.
### Строковые литералы
[строковые и символьные литералы](https://docs.microsoft.com/ru-ru/cpp/cpp/string-and-character-literals-cpp?view=msvc-170)
Строковый литерал – последовательность символов в " " с завершающим нулем.
raw string literal - необработанные строковые литералы [пример](https://www.geeksforgeeks.org/raw-string-literal-c/)

### Склейка подряд написанных строковых литералов на этапе компиляции 
```c++
    std::string s1 = "hello" "world"; //препроцессор склеит в один строковый литерал
    std::string s2 = "he\n\t\xFF" R"foo(Hello World)foo"; //и обработает все эти штуки 
    "AB" + "CD"; //не скомпилируется
```

### static_cast<> 
Приведения типов, есть еще вариант в стиле C - (int), но со сложными типами static_cast<> безопаснее
Пример избавления от переполнения при умножении int'ов.
```c++
int x = 1e9; 
long long y = x * x; 
```
Будет UB, тк выполнится вначале правая часть int * int = int, а тут переполнение типа. 
Решение:
```c++
int x = 1e9; 
long long y = static_cast<long long> (x) * x; 
```
### Разница между i++ и ++i.
i++ - возвращает значение, увеличивает  
++i - наоборот
```c++
a = b++; // a = b; b++;
a = ++b; // b++; a = b;
```
### Составные операторы присваивания
сокращенные операторы присваивания типа *=, /=, %=
Возвращают ссылку на объект
` y = x += 10; // x+= 10; y = x;`
### Expression и statement
expression - выражение, что-то вычисляющее значение: выражения, вызовы функций, обращения к переменной [примеры](https://en.cppreference.com/w/cpp/language/expressions) 
statement - инструкция, команда. Что-то типа if, while, for, объявления переменных [примеры](https://en.cppreference.com/w/cpp/language/statements)
[пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/05-210930/00-before/00-comma.cpp)
[типы expression](https://docs.microsoft.com/en-us/cpp/cpp/types-of-expressions?view=msvc-170)
### Оператор ,
[этот же пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/05-210930/00-before/00-comma.cpp)
Объединяет выражения, вычисляет их, возвращает результат правого. Циклы через запятую не записать, тк это statement.
Еще используется, когда несколько параметров в цикле.
Еще пример (у запятой низкий приоритет):
```c++
a = b, c; // a = b
a = (b,c); // a = c
```
### Синтаксис: for, while, if.
E - expression, S - statement
```c++
for(E,E,E)
    S
```
[цикл](https://en.cppreference.com/w/cpp/language/for)
например: 
```c++
for (int i = 0; //происходит перед циклом 
i < n; //проверяется перед каждой итерацией 
i++) { //выполняется в конце каждой итерации 
} 
```
break - выход из цикла 
continue - следующая итерация

```c++
while(E)
    S
```
```c++
if(E) // еще может быть if(<создание переменной>; E)
    S1
else 
    S2
```
### Тернарный оператор
<проверяемое условие> ? <оператор выбора 1> : <оператор выбора 2> 
Может возникнуть проблема,когда ветки разных типов, тогда непонятно, какой тип возвращать:
[пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/blob/master/04-210923/01-functions/02-lcm.cpp)
[таймкод](https://youtu.be/f2aiF6dQQ7c?t=217)
### Range-based for
[cppreference](https://en.cppreference.com/w/cpp/language/range-for)
Вместо for (int i = 0; i < n; ++i) - for (int x : vec) - инициализируется новая переменная x на каждой итерации, в которую копируется элемент вектора.
Если взять по ссылке: 
for (int &x : vec)
то можно изменить значение переменной в векторе, копирования не происходит.
Константная ссылка - нельзя изменить значение переменной, копирования не происходит.

auto - в некоторых контейнерах удобнее писать auto it, чем typename std::set<int>::iterator it;
Каким типом будет auto определяется во время компиляции
Можно использовать auto, когда храним пары или некоторые структуры, итерируемся по map.
[примеры](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/01-extra-stl/03-map.cpp)
`auto a; // не скомпилируется` 
### Порядок вычислений
[ссылка](https://notes.algoprog.ru/cpp/additional.html#id4)
Если вкратце: 
порядок вычислений аргументов функций происходит на усмотрение компилятора, когда он хочет что-то соптимизировать 
в логических операторах  `if(i < v.size() && v[i] == 0)` - порядок слева направо
инициализация переменных в порядке объявления
`f(), b() // через запятую тоже все в порядке`
при инициализации при помощи {} (обычно у вектора) порядок тоже слева направо
в стандарте C++17 в некоторых выражениях зафиксирован порядок вычислений: слева-направо вычисляются выражения при вводе через >> и выводе через << . При присваивании через =, +=  и похожие операторы: сначала вычисляется часть справа, а потом часть слева. 
Пример:
```c++
int a,b;
a = b = 5; // b = 5; a = b;
```
если бы порядок был другой, получили бы UB

